Virtual Machine
1. software simulation of a machine which can perform operations like a physical machine
2. 2 types of VM
i. hardware/system based VM
ii. application/process based VM

hardware/system based VM
1. provides several logical systems on the same computer with strong isolation from each other
2. on one physical machine we are defining multiple logical machines
3. main advantage of hardware based VM is hardware resources sharing and improves utilization of hardware resources
4. E.g. KVM (kernel based VM for Linux systems), VMware, Xen, Cloud computing etc.

application/process based VM
1. act as runtime engines to run particular programming language applications
2. E.g. JVM acts as runtime engine to run Java based applications, PVM (Parrot VM) acts as runtime engine to run Perl based application, CLR (Common Language Runtime) acts as runtime engine to run .NET based applications

JVM
1. JVM is part of JRE which is again part of JDK
2. JVM is responsible for 2 activities
i. load java *.class files
ii. run java *.class file

JVM Architecture Diagram
1. Classloader subsystems - read and load *.class files into various memory areas of JVM
2. Memory area
i. method area
ii. heap area
iii. stack area
iv. PC registers
v. native method stacks
3. Execution engine - read and execute *.class files from memory area and execute
i. requires native method libraries
ii. Java Native Interface (JNI) acts as bridge between Execution engine and native method libraries

Classloader subsystem
1. responsible for following 3 activities
i. Loading
a. read *.class file from disk and store corresponding binary data in method area of JVM memory area
b. for each class file, JVM stores corresponding info in method area
- FQN (Fully Qualified Name) of class
- FQN of parent class
- method info
- variables info
- Constructors
- modifier info
- constant pool info
c. after loading *.class file, JVM creates an object for that loaded class in heap memory area of type java.lang.Class
d. java.lang.Class object can be used by programmer to get class level information like methods, variables, constructors information etc. [Java Reflection API]
e. only one java.lang.Class object is created for a particular class by JVM
ii. Linking
a. Verify 
- process of ensuring that binary representation of class is structurally correct or not
- JVM check where *.class file is generated by valid compiler or not
- checks whether *.class is properly formatted or not
- internally ByteCode verifier is responsible for this activity
- ByteCode verifier is part of Classloader subsystem
- if verification fails, then we will get Runtime exception java.lang.VerifyError
b. Prepare
- JVM allocates memory for class level static variable and assign default values
- in Initialization phase, original values will be assigned to the static variables
c. Resolve
- replacing symbolic names in our program with original memory references from method area
- the names of symbols are stored in constants pool
- in resolution phase, the names of these symbols are replaced with original memory level references from method area
iii. Initialization
- all static variables are assigned with original values and static blocks will be executed from parent to child and from top to bottom
2. while loading, linking and initialization, if any error occurs, then we will get Runtime exception java.lang.LinkageError

Types of Classloaders
1. Bootstrap class loader/primordial class loader
- responsible to load Core Java API class i.e. classes present in rt.jar
- responsible to load classes from bootstrap classpath - jdk/jre/lib
- by default available with every JVM
- implemented in native languages like C/C++ and not in Java
2. Extension class loader
- child class of Bootstrap class loader
- responsible to load classes from extension classpath - jdk/jre/lib/ext
- implemented in Java and corresponding .class file is sun.misc.Launcher$ExtClassLoader.class
3. Application class loader/system class loader
- child class of Extension class loader
- responsible to load classes from application classpath - using environment variable classpath
- implemented in Java and corresponding .class file is sun.misc.Launcher$AppClassLoader.class
4. Classloader follows Delegation hierarchy algorithm
- when JVM comes across particular class, checks if .class file is already 
- if present in method area, it will be considered
- if not, request to Classloader subsystem
- classloader subsystem requests Application classloader 
- Application classloader request to Extension classloader
- Extension classloader request to Bootstrap classloader
- BCL checks BCP to load class, if not present delegates to ECL
- ECL check ECP to load class, if not present delegates to ACL
- ACL checks ACP to load class, if not present throws ClassNotFoundException or NoClassDefFoundError
5. if same .class file is present in multiple classpaths then priority is BCL > ECL > ACL

Customized class loader
1. default CL loads .class file only once even though it is used multiple times in our program
2. after loading .class file if it is modified outside, then default CL won't load updated version of .class file because .class file is already available in method area
3. we can resolve this problem by defining our own customized CL
4. advantage is we can control class loading mechanism based on our requirement
5. e.g. we can load .class file separately everytime so that updated version is available to our program
6. every class loader in Java should be child class of java.lang.ClassLoader either directly or indirectly. this class acts as base class for all customized class loaders
7. create new class loader by extending this class and override loadClass method which returns java.lang.Class object of .class file

Memory area in JVM
1. method area
- for every JVM, one method area will be available
- created at time of JVM startup
- class level binary data including static variables will be stored in method area
- constant pools of a class will be stored in method area
- method area can be accessed by multiple threads simultaneously
2. heap area
- for every JVM, one heap area will be available
- created at time of JVM startup
- objects and corresponding instance variable stored in heap area
- every array in Java is object, hence stored in heap area
- heap area can be accessed by multiple threads and hence data stored in heap area is not thread safe
- need not be continuous memory
- heap memory stats (in bytes) using Runtime class methods
-- maxMemory - max memory allocated to the heap
-- totalMemory - total/initial memory allocated to heap
-- freeMemory - free memory present in the heap
-- consumer memory = total memory - free memory
- set min and max heap size using -Xms and -Xmx arguments for a Java program
3. stack area
- JVM creates one Runtime stack area for each thread at time of thread creation
- each method call performed by the thread and corresponding local variables pushed to stack
- after completing a method, the corresponding entry from the stack will be removed
- after completing all method calls, stack becomes empty and empty stack will be destroyed by JVM just before terminating the thread
- each entry in the stack is call Stack Frame or Activation Record
- data stored in stack is available for corresponding thread only and not available to remaining threads, hence thread safe
- each Stack Frame contains 3 parts
i. local variable array
-- contains all parameters and local variables of the method
-- each slot in the array is of 4 bytes
-- int, float and object reference occupy 1 entry in the array
-- double, long occupy 2 consecutive entries in the array
-- byte, short, char values will be converted to int type before storing and occupy 1 slot in the array
-- way of storing boolean values varies from JVM to JVM. most JVMs follow 1 slot for boolean values
ii. operand stack
- JVM uses operand stack as workspace
- some instructions push/pop values to/from operand stack and some instructions can perform required operations
iii. frame data
- all symbolic references used in a method is stored in frame data
- contains reference to exception table which provides corresponding catch-block information in case of exception
4. PC (Program Counter) registers
- for each thread, separate PC register is created at time of thread creation
- PC registers contains address of current executing instruction
- one instruction execution completes, automatically PC register will be incremented to hold address of next instruction
5. native method stacks
- for each thread, JVM creates separate native method stack
- all native method calls invoked by the thread will be stored in the corresponding native method stack
6. Method area, heap area and stack area are considered important memory areas w.r.t. programmer
7. method area and heap area are per JVM. for every JVM, one method area and one heap area
8. stack area, PC registers and native method stack are per thread. for every thread, one stack area, one PC register and one native method stack area
9. static variables stored in method area
10. instance variables stored in heap area
11. local variables stored in stack area

Execution engine
1. central component of JVM responsible to execute Java class files
2. EE contains two components
i. Interpreter
ii. JIT compiler

Interpreter
1. read byte code line by line
2. interpret byte code and convert to machine code (native code)
3. execute machine code line by line
4. it interprets everytime even when same method is invoked multiple times which reduces performance of the system

JIT compiler
1. improve performance
2. internally JIT compiler maintains separate count for every method
3. when JVM encounters a method call, method is interpreted normally by the interpreter and JIT compiler increments corresponding count variable
4. this process happens for every method
5. if this method call count reaches a threshold value, then JIT compiler identifies that the method is repeatedly used method (Hot spot)
6. JIT compiler compiles that method and generates corresponding machine code (native code)
7. next time JVM encounters that method call, JVM uses the native code directly and executes it instead of interpreting it once again so that performance of the system will be improved
8. threshold count varies from JVM to JVM
9. some advanced JIT compilers will recompile generated native code if count reaches threshold value second time, so that more optimized machine code will be generated
10. Internally Profiler, which is part of JIT compiler is responsible to identify hot spots
11. JVM interprets whole program atleast once
12. JIT compilation is applicable only for repeatedly required methods and not for every method
13. Execution engine components
i. Interpreter
ii. JIT compiler
iii. Intermedia code generator
iv. Code optimizer
v. Target code generator
vi. Profiler

Java Native Interface
1. acts as mediator for Java method calls and corresponding native libraries
2. responsible to provide information about native libraries to JVM
3. native method libraries holds native libraries information

JVM complete picture
1. *.java source files compiled by Java compiler with javac command and generates *.class files
2. *.class file is input to Class loader subsystem
i. Loading - Bootstrap CL (loads core java API classes), Extension CL (jre/jvm/lib/ext), Application CL. Priority BCL > ECL > ACL
ii. Linking - Verify (the bytecode), Prepare (static variable memory allocation and default values assigned), Resolve (symbolic references replaced with original references from method area)
iii. Initialization - initialization (static variable original values assigned and static blocks executed)
3. JVM memory areas
i. method area - per JVM, stores class level data, static variables
ii. heap area - per JVM, object data, java.lang.Class objects, instance variables, arrays
iii. stack area - runtime stack per thread, each entry (stack frame) in stack contains local variable array (method calls, local variables), frame data (symbols used in method, catch-block information), operand stack (runtime workspace)
iv. PC registers - PC register per thread holds address of current executing instruction, once completed will be updated to next instruction
v. native method stacks - stack per thread
4. Execution engine
i. Interpreter
ii. JIT compiler (applicable only for repeated required methods) contains intermediate code generator, code optimizer, target code generator which generates machine code/native code, Profiler (identifies Hot spots/frequently used methods)
iii. Garbage collector
iv. Java native interface provides native method libraries information

java.lang.Class file
1. major_version, minor_version 
- represent *.class file version used to identify which version of compiler generates current *.class file
- lower version generated *.class file can be higher level JVM
- higher version generated *.class file cannot be run by lower level JVM. UnsupportedclassversionError runtime error will be thrown
- Java1.5 - 49.0, 1.6 - 50.0, 1.7 - 51.0
2. magic number 
- first 4 bytes is 0xCAFEBABE - to verify valid *.class file generated by compiler)
3. constant_pool[]
- represents information present in constant pool
4. access_flags
- information about modifiers declared to the class
5. this_class
- represents Fully Qualified Name of the class
6. super_class
- represents Fully Qualified Name of immediate super class or current class
7. interface[]
- provides interfaces information implemented by current class
8. fields[]
- provides fields information present in current class
9. methods[]
- provides information of all the methods present in current class
10. attributes[]
- provides information about all attributes present in current class